
* Imperative programming uses a thread per request(Tomcat).
* Reactive programming uses a loop of events(Netty) with no blocking threads.

* Traditional JDBC uses blocking threads with HikariCP
* R2DBC uses a Reactive Connection Pool that keeps open connections (async)


***********************************************************************

"Real-Time Fraud Alert System"

Componentes Técnicos de la Solución

1. Ingesta: Transaction-Producer (WebFlux + Kafka)
    En lugar de un controlador REST tradicional, este servicio manejará las transacciones entrantes de forma asíncrona.
    Tecnología: Spring WebFlux + Reactor Kafka.
    Clave: El uso de KafkaSender de Project Reactor permite que el envío del mensaje sea una operación no bloqueante que devuelve un Mono<SenderResult<Void>>.

2. El Cerebro: Fraud-Processor (Stream Processing)
    Este es el corazón reactivo. Consumirá el flujo de Kafka como un Flux<Transaction>.
    Estrategia de Ventana (Windowing): Podrías usar operadores como window() o buffer() para analizar, por ejemplo, si un usuario ha hecho más de 5 transacciones en los últimos 30 segundos (detección de patrones).
    Backpressure: Si Kafka envía datos más rápido de lo que tu lógica de fraude puede procesar, el flujo reactivo gestionará la demanda para no desbordar la memoria (Heap).

3. Persistencia: R2DBC y Redis Reactivo
    Aquí es donde muchos fallan. Si usas Hibernate tradicional (JDBC), bloqueas los hilos de Netty.
    R2DBC (Reactive Relational Database Connectivity): Para persistir las transacciones sospechosas en PostgreSQL sin bloquear.
    Spring Data Reactive Redis: Para consultar en milisegundos las "listas negras" o límites de crédito.

4. Observabilidad (Tu especialidad)
    Dado que en el mundo reactivo el "Stack Trace" tradicional se vuelve confuso (porque los hilos saltan de una tarea a otra), la arquitectura incluirá:
    Micrometer Tracing: Para propagar el traceId a través de los flujos asíncronos.
    Kibana/Dynatrace: Para monitorear el rendimiento de los Event Loops.

***********************************************************************

Levantar base de datos postgres:

docker-compose up -d

Para testear:
docker exec -it reactive-postgres-banking psql -U user_banking -d fraud_db -c "SELECT customer_id, daily_max_amount FROM customer_limits;"
docker exec -it reactive-postgres-banking psql -U user_banking -d fraud_db -c "SELECT count(*) FROM transactions;"

Configurar healt-check para evitar caídas de app si la bd no está disponible o aún está levantando

***********************************************************************

Datos nuevos e importantes:

ISO Codes: Usar mcc (Merchant Category Code) es vital; si un cliente de Lima compra en una joyería en Rusia 5 minutos después de comprar un café en San Isidro, tu lógica reactiva detectará el fraude de inmediato.
Índices para no hacer full table scan sino ir a los registros adecuados en millis